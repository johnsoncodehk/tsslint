import type * as TSSLint from '@tsslint/types';
import type { IOptions, IRule, IRuleMetadata, ITypedRule } from 'tslint';
import type * as ts from 'typescript';
import * as path from 'path';
import * as fs from 'fs';

type O<T extends any[]> = boolean | T; // Corrected: boolean or array of options

// Placeholder for TSLintRulesConfig - will be generated by a script later
export interface TSLintRulesConfig {
	// Example: 'no-unused-variable': ['check-parameters']
	[ruleName: string]: any;
}

// Helper function to convert kebab-case to PascalCase
function toPascalCase(kebabCase: string): string {
	return kebabCase.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join('');
}

// Helper function to find TSLint rule class
async function findTslintRule(ruleName: string, rulesDirectory?: string | string[]): Promise<{ metadata?: IRuleMetadata; new(options: IOptions): IRule; } | undefined> {
	const pascalCaseRuleName = toPascalCase(ruleName) + 'Rule';

	// 1. Try to load from tslint/lib/rules (built-in rules)
	try {
		const tslint = require('tslint'); // Dynamically require tslint
		const Rule = tslint.Rules[pascalCaseRuleName];
		if (Rule) {
			return Rule;
		}
	} catch (e) {
		// console.error(`[TSSLint/TSLint] Error loading built-in rule ${ruleName}:`, e);
	}

	// 2. Try to load from specified rulesDirectory
	const directories = Array.isArray(rulesDirectory) ? rulesDirectory : (rulesDirectory ? [rulesDirectory] : []);
	for (const dir of directories) {
		const rulePath = path.join(dir, ruleName + '.js'); // TSLint rules are often .js files
		if (fs.existsSync(rulePath)) {
			try {
				// TSLint custom rules usually export a class directly
				const Rule = require(rulePath).Rule; // Assuming the class is exported as 'Rule'
				if (Rule) {
					return Rule;
				}
			} catch (e) {
				console.error(`[TSSLint/TSLint] Failed to load rule from ${rulePath}:`, e);
			}
		}
	}

	// 3. Try to load from node_modules for plugin rules (e.g., tslint-plugin-foo)
	// This is more complex as TSLint plugins often export rules differently.
	// For simplicity, we'll assume a direct require for now, but a more robust solution
	// would involve parsing plugin's package.json or conventions.
	// Example: tslint-plugin-foo -> require('tslint-plugin-foo').Rules['NoFooRule']
	try {
		const pluginName = ruleName.split('/')[0]; // e.g., '@angular-eslint/template'
		if (pluginName.startsWith('tslint-plugin-') || pluginName.startsWith('@')) {
			const plugin = require(pluginName); // Dynamically require the plugin package
			const Rule = plugin.Rules?.[pascalCaseRuleName]; // Try to find in plugin.Rules
			if (Rule) {
				return Rule;
			}
		}
	} catch (e) {
		// console.error(`[TSSLint/TSLint] Error loading plugin rule ${ruleName}:`, e);
	}

	console.warn(`[TSSLint/TSLint] TSLint rule '${ruleName}' not found.`);
	return undefined;
}

/**
 * Converts a TSLint rules configuration to TSSLint rules.
 *
 * The type definitions are generated when `@tsslint/tslint` is installed.
 * If the type definitions become outdated, please run
 * `node node_modules/@tsslint/tslint/scripts/generateDts.js` to update them.
 */
export async function defineRules(
	config: { [K in keyof TSLintRulesConfig]: O<TSLintRulesConfig[K]> },
	category: ts.DiagnosticCategory = 3 satisfies ts.DiagnosticCategory.Message,
	rulesDirectory?: string | string[]
): Promise<Record<string, TSSLint.Rule>> {
	const tsslintRules: Record<string, TSSLint.Rule> = {};

	for (const [rule, configValue] of Object.entries(config)) {
		let enabled: boolean;
		let options: any[];

		if (Array.isArray(configValue)) {
			enabled = true;
			options = configValue;
		} else {
			enabled = configValue;
			options = [];
		}

		if (!enabled) {
			tsslintRules[rule] = () => { }; // Noop rule if disabled
			continue;
		}

		const RuleClass = await findTslintRule(rule, rulesDirectory);

		if (!RuleClass) {
			throw new Error(`Failed to resolve TSLint rule "${rule}".`);
		}

		tsslintRules[rule] = convertRule(
			RuleClass,
			options,
			category
		);
	}

	return tsslintRules;
}

export function convertRule(
	Rule: {
		metadata?: IRuleMetadata;
		new(options: IOptions): IRule;
	},
	ruleArguments: any[] = [],
	category: ts.DiagnosticCategory = 3 satisfies ts.DiagnosticCategory.Message,
): TSSLint.Rule {
	const rule = new Rule({
		ruleName: Rule.metadata?.ruleName ?? 'unknown',
		ruleArguments,
		ruleSeverity: 'warning',
		disabledIntervals: [],
	}) as IRule | ITypedRule;
	return ({ file, languageService, report }) => {
		const failures = 'applyWithProgram' in rule
			? rule.applyWithProgram(file, languageService.getProgram()!)
			: rule.apply(file);
		for (const failure of failures) {
			const reporter = report(
				failure.getFailure(),
				failure.getStartPosition().getPosition(),
				failure.getEndPosition().getPosition(),
				category,
				[new Error(), Number.MAX_VALUE]
			);
			if (failure.hasFix()) {
				const ruleName = Rule.metadata?.ruleName;
				reporter.withFix(
					ruleName ? `Fix with ${ruleName}` : 'Fix',
					() => {
						const fix = failure.getFix();
						const replaces = Array.isArray(fix) ? fix : fix ? [fix] : [];
						return [{
							fileName: file.fileName,
							textChanges: replaces.map(replace => ({
								newText: replace.text,
								span: {
									start: replace.start,
									length: replace.length,
								},
							})),
						}];
					},
				);
			}
		}
	};
}
