import type * as TSSLint from '@tsslint/types';
import type { IOptions, IRule, IRuleMetadata } from 'tslint';
import { convertRule } from './index';
import * as path from 'path';
import * as fs from 'fs';
import * as ts from 'typescript';

type S = boolean;
type O<T extends any[]> = S | [S, ...options: T];

// Placeholder for TSLintRulesConfig - will be generated by a script later
export interface TSLintRulesConfig {
  // Example: 'no-unused-variable': [true, 'check-parameters']
  [ruleName: string]: any;
}

// Helper function to convert kebab-case to PascalCase
function toPascalCase(kebabCase: string): string {
  return kebabCase.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join('');
}

// Helper function to find TSLint rule class
async function findTslintRule(ruleName: string, rulesDirectory?: string | string[]): Promise<{ metadata?: IRuleMetadata; new(options: IOptions): IRule; } | undefined> {
  const pascalCaseRuleName = toPascalCase(ruleName) + 'Rule';

  // 1. Try to load from tslint/lib/rules (built-in rules)
  try {
    const tslint = require('tslint'); // Dynamically require tslint
    const Rule = tslint.Rules[pascalCaseRuleName];
    if (Rule) {
      return Rule;
    }
  } catch (e) {
    // console.error(`[TSSLint/TSLint] Error loading built-in rule ${ruleName}:`, e);
  }

  // 2. Try to load from specified rulesDirectory
  const directories = Array.isArray(rulesDirectory) ? rulesDirectory : (rulesDirectory ? [rulesDirectory] : []);
  for (const dir of directories) {
    const rulePath = path.join(dir, ruleName + '.js'); // TSLint rules are often .js files
    if (fs.existsSync(rulePath)) {
      try {
        // TSLint custom rules usually export a class directly
        const Rule = require(rulePath).Rule; // Assuming the class is exported as 'Rule'
        if (Rule) {
          return Rule;
        }
      } catch (e) {
        console.error(`[TSSLint/TSLint] Failed to load rule from ${rulePath}:`, e);
      }
    }
  }

  // 3. Try to load from node_modules for plugin rules (e.g., tslint-plugin-foo)
  // This is more complex as TSLint plugins often export rules differently.
  // For simplicity, we'll assume a direct require for now, but a more robust solution
  // would involve parsing plugin's package.json or conventions.
  // Example: tslint-plugin-foo -> require('tslint-plugin-foo').Rules['NoFooRule']
  try {
    const pluginName = ruleName.split('/')[0]; // e.g., '@angular-eslint/template'
    if (pluginName.startsWith('tslint-plugin-') || pluginName.startsWith('@')) {
      const plugin = require(pluginName); // Dynamically require the plugin package
      const Rule = plugin.Rules?.[pascalCaseRuleName]; // Try to find in plugin.Rules
      if (Rule) {
        return Rule;
      }
    }
  } catch (e) {
    // console.error(`[TSSLint/TSLint] Error loading plugin rule ${ruleName}:`, e);
  }

  console.warn(`[TSSLint/TSLint] TSLint rule '${ruleName}' not found.`);
  return undefined;
}

/**
 * Converts a TSLint rules configuration to TSSLint rules.
 *
 * The type definitions are generated when `@tsslint/tslint` is installed.
 * If the type definitions become outdated, please run
 * `node node_modules/@tsslint/tslint/scripts/generateDts.js` to update them.
 */
export async function defineRules(
  config: { [K in keyof TSLintRulesConfig]: O<TSLintRulesConfig[K]> },
  category: ts.DiagnosticCategory = ts.DiagnosticCategory.Message,
  rulesDirectory?: string | string[]
): Promise<Record<string, TSSLint.Rule>> {
  const tsslintRules: Record<string, TSSLint.Rule> = {};

  for (const [rule, severityOrOptions] of Object.entries(config)) {
    let severity: S;
    let options: any[];
    if (Array.isArray(severityOrOptions)) {
      [severity, ...options] = severityOrOptions;
    }
    else {
      severity = severityOrOptions;
      options = [];
    }

    if (!severity) {
      tsslintRules[rule] = () => {}; // Noop rule if disabled
      continue;
    }

    const RuleClass = await findTslintRule(rule, rulesDirectory);

    if (!RuleClass) {
      throw new Error(`Failed to resolve TSLint rule "${rule}".`);
    }

    tsslintRules[rule] = convertRule(
      RuleClass,
      options,
      category
    );
  }

  return tsslintRules;
}
